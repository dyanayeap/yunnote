## 例1：求x的n次方 x^n^

方法1：时间复杂度为O(n)

```cpp
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

方法2：采用递归 时间复杂度为O(n)

```cpp
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

方法3：时间复杂度O(n)

```cpp
int function3(int x, int n) {
    if (n == 0) {
        return 1;
    }
    //如果指数为奇数
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    //如果指数为偶数
    return function3(x, n / 2) * function3(x, n / 2);
}
//假如n = 16
//则会被分为function3(x, 8)*function3(x, 8)
//接下来 4*4   4*4
//接下来 2*2 2*2 2*2 2*2 即n*n n*n n*n n*n
```

方法4:时间复杂度O(logn)

```cpp
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
//若n=16 t = function4(x, 8)
//function4(x, 8)*function4(x, 8)
//function4(x, 4)*function4(x, 4)
//function4(x, 2)*function4(x, 2)
//t = function4(x, 1)
//function4(x, 1)*function4(x, 1)*1

```

## 例2：斐波那契数列

方法1：采用递归方法

```cpp
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```

方法2：优化递归算法，减少了一次递归

```cpp
// 版本二
//利用first和second来记录当前相加的两个数值
int fibonacci(int first, int second, int n) {
    if (n <= 0) {
        return 0;
    }
    if (n < 3) {
        return 1;
    }
    else if (n == 3) {
        return first + second;
    }
    else {
        return fibonacci(second, first + second, n - 1);
    }
}
```

## 例3：二分法递归实现

```cpp
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```

## 例4：二分查找leetcode 704

![image-20220520204333604](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81.assets/image-20220520204333604.png)

思路：**这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。



**解法1：**可以自己写出

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1;
        int mid = (right-left)/2;
    while(left<=right){
        if(nums[mid]<target){
            left = mid+1;
            mid = (right+left)/2;
        }
        else if(nums[mid]>target){
            right = mid -1;
            mid = (right-left)/2;
        }
        else{
            return mid;
        }
    }
    return -1;
    }
};
```

**解法2**：对于左闭右开区间[a,b)

```cpp
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

## 例5：leetcode35 搜索插入位置

![image-20220520221851107](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81.assets/image-20220520221851107.png)

思路：

![image-20220520221911641](%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81.assets/image-20220520221911641.png)

**解法1：**

二分法（可以写出来）

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0 ;
        int right = nums.size() - 1;
        
        while(left<=right){
            int mid =((left+right)/2);
            if(nums[mid] < target){
                    left = mid+1;
                    //mid = (left+right) / 2;
             }
             else if(nums[mid] > target){
                 right = mid -1;
                 //mid = (left+right) / 2;
             }
             else{
                 return mid;
             }   
        }       
        return right+1;
    }
};




//标准答案
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle;
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
        return right + 1;
    }
};
```

解法2：

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里，[left, right)  target
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return middle
        // 目标值插入数组中的位置 [left, right) ，return right 即可
        // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
        return right;
    }
};
```
