## 例1：求x的n次方 x^n^

方法1：时间复杂度为O(n)

```cpp
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

方法2：采用递归 时间复杂度为O(n)

```cpp
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

方法3：时间复杂度O(n)

```cpp
int function3(int x, int n) {
    if (n == 0) {
        return 1;
    }
    //如果指数为奇数
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    //如果指数为偶数
    return function3(x, n / 2) * function3(x, n / 2);
}
//假如n = 16
//则会被分为function3(x, 8)*function3(x, 8)
//接下来 4*4   4*4
//接下来 2*2 2*2 2*2 2*2 即n*n n*n n*n n*n
```

方法4:时间复杂度O(logn)

```cpp
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
//若n=16 t = function4(x, 8)
//function4(x, 8)*function4(x, 8)
//function4(x, 4)*function4(x, 4)
//function4(x, 2)*function4(x, 2)
//t = function4(x, 1)
//function4(x, 1)*function4(x, 1)*1

```

## 例2：斐波那契数列

方法1：采用递归方法

```cpp
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```

方法2：优化递归算法，减少了一次递归

```cpp
// 版本二
//利用first和second来记录当前相加的两个数值
int fibonacci(int first, int second, int n) {
    if (n <= 0) {
        return 0;
    }
    if (n < 3) {
        return 1;
    }
    else if (n == 3) {
        return first + second;
    }
    else {
        return fibonacci(second, first + second, n - 1);
    }
}
```

## 例3：二分法递归实现

```cpp
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```

